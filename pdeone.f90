      SUBROUTINE PDEONE(T, U, UDOT, NPDE, NPTS)
        use mod_pdeone, only: x, icord
        use mod_user, only: bndry,f,d
        implicit integer (i-n)
        implicit real (a-h,o-z)
        integer, intent(in) :: npde,npts
        real, intent(in) :: t
        real, intent(inout) :: u(npde,npts)
        real, intent(out) :: udot(npde,npts)
!         external bndry,f,d
! PDEONE IS AN INTERFACE SUBROUTINE WHICH USES CENTERED DIF-
! FERENCE APPROXIMATIONS TO CONVERT ONE-DIMENSIONAL SYSTEMS
! OF PARTIAL DIFFERENTIAL EQUATIONS INTO A SYSTEM OF ORDINARY
! DIFFERENTIAL EQUATIONS, UDOT = F(T,X,U).  THIS ROUTINE IS
! INTENDED TO BE USED WITH A ROBUST ODE INTEGRATOR.
! INPUT..
!  NPDE = NUMBER OF PARTIAL DIFFERENTIAL EQUATIONS.
!  NPTS = NUMBER OF SPATIAL GRID POINTS.
!     T = CURRENT VALUE OF TIME.
!     U = AN NPDE BY NPTS ARRAY CONTAINING THE COMPUTED
!         SOLUTION AT TIME T.
! OUTPUT..
!  UDOT = AN NPDE BY NPTS ARRAY CONTAINING THE RIGHT HAND
!         SIDE OF THE RESULTING SYSTEM OF ODE*S, F(T,X,U),
!         OBTAINED BY DISCRETIZING THE GIVEN PDE*S.
! THE USER MUST INSERT A DIMENSION STATEMENT OF THE FOLLOW-
! ING FORM..
      real :: DVAL(NPDE,NPDE,2),UX(NPDE),UAVG(NPDE)
      real :: alpha(npde),beta(npde), gamma_(npde)
      integer :: k, l
! THE SYMBOLS ** DENOTE THE ACTUAL NUMERICAL VALUE OF NPDE
! FOR THE PROBLEM BEING SOLVED.
! COMMON BLOCK MESH CONTAINS THE USER SPECIFIED SPATIAL
! GRID POINTS.
! COMMON BLOCK COORD CONTAINS 0,1, OR 2 DEPENDING ON WHETHER
! THE PROBLEM IS IN CARTESIAN, CYLINDRICAL, OR SPHERICAL
! COORDINATES, RESPECTIVELY.
!      COMMON /MESH/ X(1)
!      COMMON /COORD/ ICORD
      ICORD1 = ICORD + 1
! UPDATE THE LEFT BOUNDARY VALUES
      CALL BNDRY(T, X(1), U, ALPHA, BETA, GAMMA_, NPDE)
      ITEST = 0
      DXI = 1./(X(2)-X(1))
      DO K=1,NPDE
        IF (BETA(K).NE.0.0) cycle
        U(K,1) = GAMMA_(K)/ALPHA(K)
        ITEST = ITEST + 1
      end do
      IF (ITEST.NE.NPDE) THEN
        IF (ITEST.NE.0) THEN
          CALL BNDRY(T, X(1), U, ALPHA, BETA, GAMMA_, NPDE)
        END IF
  ! EVALUATE D COEFFICIENTS AT THE LEFT BOUNDARY
        CALL D(T, X(1), U, DVAL, NPDE)
  ! FORM APPROXIMATIONS TO DU/DX AT THE LEFT BOUNDARY
        DO K=1,NPDE
          IF (BETA(K).NE.0.0) THEN
            UX(K) = (GAMMA_(K)-ALPHA(K)*U(K,1))/BETA(K)
          ELSE
            UX(K) = DXI*(U(K,2)-U(K,1))
          END IF
        END DO
      END IF
! EVALUATE U-AVERAGE IN THE FIRST INTERVAL
      DO K=1,NPDE
        UAVG(K) = .5*(U(K,2)+U(K,1))
      END DO
! EVALUATE D COEFFICIENTS IN THE FIRST INTERVAL
      XAVGR = .5*(X(2)+X(1))
      CALL D(T, XAVGR, UAVG, DVAL(1,1,2), NPDE)
      DXIL = 1.
      DXIR = DXI
      IF (ICORD.NE.0) THEN
        DXIL = X(1)**ICORD
        DXIR = DXIR*XAVGR**ICORD
      END IF
! EVALUATE DUXX AT THE LEFT BOUNDARY
      IF (ITEST.NE.NPDE) THEN
        DXIC = real(ICORD1)/(XAVGR**ICORD1-X(1)**ICORD1)
        DO L=1,NPDE
          DO K=1,NPDE
            DVAL(K,L,1) = DXIC*(DVAL(K,L,2)*(U(L,2)-U(L,1))*DXIR-DVAL(K,L,1)*UX(L)*DXIL)
          END DO
        END DO
  ! EVALUATE RIGHTHAND SIDE OF PDE*S AT THE LEFT BOUNDARY
        CALL F(T, X(1), U, UX, DVAL, UDOT, NPDE)
      END IF
! SET UDOT = 0 FOR KNOWN LEFT BOUNDARY VALUES
      DO K=1,NPDE
        IF (BETA(K).EQ.0.0) UDOT(K,1) = 0.0
      END DO
! UPDATE THE RIGHT BOUNDARY VALUES
      CALL BNDRY(T, X(NPTS), U(1,NPTS), ALPHA, BETA, GAMMA_, NPDE)
      ITEST = 0
      DO K=1,NPDE
        IF (BETA(K).NE.0.0) cycle
        U(K,NPTS) = GAMMA_(K)/ALPHA(K)
        ITEST = ITEST + 1
      END DO
      IBCK = 1
      IFWD = 2
      ILIM = NPTS - 1
! MAIN LOOP TO FORM ORDINARY DIFFERENTIAL EQUATIONS AT THE
! GRID POINTS
      main: DO I=2,ILIM
        K = IBCK
        IBCK = IFWD
        IFWD = K
        XAVGL = XAVGR
        XAVGR = .5*(X(I+1)+X(I))
        DXI = 1./(X(I+1)-X(I-1))
        DXIL = DXIR
        DXIR = 1./(X(I+1)-X(I))
        IF (ICORD.NE.0) DXIR = DXIR*XAVGR**ICORD
        DXIC = real(ICORD1)/(XAVGR**ICORD1-XAVGL**ICORD1)
! EVALUATE DU/DX AND U-AVERAGE AT THE I-TH GRID POINT AND
! INTERVAL RESPECTIVELY
        DO K=1,NPDE
          UX(K) = DXI*(U(K,I+1)-U(K,I-1))
          UAVG(K) = .5*(U(K,I+1)+U(K,I))
        END DO
! EVALUATE D COEFFICIENTS IN THE I-TH INTERVAL
        CALL D(T, XAVGR, UAVG, DVAL(1,1,IFWD), NPDE)
! EVALUATE DUXX AT THE I-TH GRID POINT
        DO L=1,NPDE
          DO K=1,NPDE
            DVAL(K,L,IBCK) = (DVAL(K,L,IFWD)*(U(L,I+1)-U(L,I))*DXIR-DVAL(K,L,IBCK)*(U(L,I)-U(L,I-1))*DXIL)*DXIC
          END DO
        END DO
! EVALUATE RIGHTHAND SIDE OF PDE*S AT THE I-TH GRID POINT
        CALL F(T, X(I), U(1,I), UX, DVAL(1,1,IBCK), UDOT(1,I), NPDE)
      END DO main
! FINISH UPDATING THE RIGHT BOUNDARY IF NECESSARY
      IF (ITEST.NE.NPDE) THEN
        IF (ITEST.NE.0) CALL BNDRY(T, X(NPTS), U(1,NPTS), ALPHA, BETA, GAMMA_, NPDE)
  ! EVALUATE D COEFFICIENTS AT THE RIGHT BOUNDARY
        CALL D(T, X(NPTS), U(1,NPTS), DVAL(1,1,IBCK), NPDE)
  ! FORM APPROXIMATIONS TO DU/DX AT THE RIGHT BOUNDARY
        DXI = 1./(X(NPTS)-X(ILIM))
        DO K=1,NPDE
          IF (BETA(K).NE.0.0) THEN
            UX(K) = (GAMMA_(K)-ALPHA(K)*U(K,NPTS))/BETA(K)
          ELSE
            UX(K) = DXI*(U(K,NPTS)-U(K,ILIM))
          END IF
        END DO
        DXIL = DXIR
        DXIR = 1.
        IF (ICORD.NE.0) DXIR = X(NPTS)**ICORD
        DXIC = real(ICORD1)/(X(NPTS)**ICORD1-XAVGR**ICORD1)
  ! EVALUATE DUXX AT THE RIGHT BOUNDARY
        DO L=1,NPDE
          DO K=1,NPDE
            DVAL(K,L,IBCK) = DXIC*(DVAL(K,L,IBCK)*UX(L)*DXIR-DVAL(K,L,IFWD)*(U(L,NPTS)-U(L,ILIM))*DXIL)
          END DO
        END DO
  ! EVALUATE RIGHTHAND SIDE OF PDE*S AT THE RIGHT BOUNDARY
        CALL F(T, X(NPTS), U(1,NPTS), UX, DVAL(1,1,IBCK), UDOT(1,NPTS), NPDE)
      END IF
! SET UDOT = 0 FOR KNOWN RIGHT BOUNDARY VALUES
      DO K=1,NPDE
        IF (BETA(K) == 0.0) UDOT(K,NPTS) = 0.0
      END DO
      RETURN
      END
